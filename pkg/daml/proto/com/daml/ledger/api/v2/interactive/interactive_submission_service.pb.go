// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: com/daml/ledger/api/v2/interactive/interactive_submission_service.proto

package interactive

import (
	v2 "buf-lib-poc/pkg/daml/proto/com/daml/ledger/api/v2"
	v1 "buf-lib-poc/pkg/daml/proto/com/daml/ledger/api/v2/interactive/transaction/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// [docs-entry-start: HashingSchemeVersion]
// The hashing scheme version used when building the hash of the PreparedTransaction
type HashingSchemeVersion int32

const (
	HashingSchemeVersion_HASHING_SCHEME_VERSION_UNSPECIFIED HashingSchemeVersion = 0
	HashingSchemeVersion_HASHING_SCHEME_VERSION_V2          HashingSchemeVersion = 2
)

// Enum value maps for HashingSchemeVersion.
var (
	HashingSchemeVersion_name = map[int32]string{
		0: "HASHING_SCHEME_VERSION_UNSPECIFIED",
		2: "HASHING_SCHEME_VERSION_V2",
	}
	HashingSchemeVersion_value = map[string]int32{
		"HASHING_SCHEME_VERSION_UNSPECIFIED": 0,
		"HASHING_SCHEME_VERSION_V2":          2,
	}
)

func (x HashingSchemeVersion) Enum() *HashingSchemeVersion {
	p := new(HashingSchemeVersion)
	*p = x
	return p
}

func (x HashingSchemeVersion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HashingSchemeVersion) Descriptor() protoreflect.EnumDescriptor {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_enumTypes[0].Descriptor()
}

func (HashingSchemeVersion) Type() protoreflect.EnumType {
	return &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_enumTypes[0]
}

func (x HashingSchemeVersion) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HashingSchemeVersion.Descriptor instead.
func (HashingSchemeVersion) EnumDescriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{0}
}

// Hints to improve cost estimation precision of a prepared transaction
type CostEstimationHints struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Disable cost estimation
	// Default (not set) is false
	Disabled bool `protobuf:"varint,1,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// Details on the keys that will be used to sign the transaction (how many and of which type).
	// Signature size impacts the cost of the transaction.
	// If empty, the signature sizes will be approximated with threshold-many signatures (where threshold is defined
	// in the PartyToKeyMapping of the external party), using keys in the order they are registered.
	// Optional (empty list is equivalent to not providing this field)
	ExpectedSignatures []v2.SigningAlgorithmSpec `protobuf:"varint,2,rep,packed,name=expected_signatures,json=expectedSignatures,proto3,enum=com.daml.ledger.api.v2.SigningAlgorithmSpec" json:"expected_signatures,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *CostEstimationHints) Reset() {
	*x = CostEstimationHints{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CostEstimationHints) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CostEstimationHints) ProtoMessage() {}

func (x *CostEstimationHints) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CostEstimationHints.ProtoReflect.Descriptor instead.
func (*CostEstimationHints) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{0}
}

func (x *CostEstimationHints) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *CostEstimationHints) GetExpectedSignatures() []v2.SigningAlgorithmSpec {
	if x != nil {
		return x.ExpectedSignatures
	}
	return nil
}

// Estimation of the cost of submitting the prepared transaction
// The estimation is done against the synchronizer chosen during preparation of the transaction
// (or the one explicitly requested).
// The cost of re-assigning contracts to another synchronizer when necessary is not included in the estimation.
type CostEstimation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Timestamp at which the estimation was made
	EstimationTimestamp *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=estimation_timestamp,json=estimationTimestamp,proto3" json:"estimation_timestamp,omitempty"`
	// Estimated traffic cost of the confirmation request associated with the transaction
	ConfirmationRequestTrafficCostEstimation uint64 `protobuf:"varint,2,opt,name=confirmation_request_traffic_cost_estimation,json=confirmationRequestTrafficCostEstimation,proto3" json:"confirmation_request_traffic_cost_estimation,omitempty"`
	// Estimated traffic cost of the confirmation response associated with the transaction
	// This field can also be used as an indication of the cost that other potential confirming nodes
	// of the party will incur to approve or reject the transaction
	ConfirmationResponseTrafficCostEstimation uint64 `protobuf:"varint,3,opt,name=confirmation_response_traffic_cost_estimation,json=confirmationResponseTrafficCostEstimation,proto3" json:"confirmation_response_traffic_cost_estimation,omitempty"`
	// Sum of the fields above
	TotalTrafficCostEstimation uint64 `protobuf:"varint,4,opt,name=total_traffic_cost_estimation,json=totalTrafficCostEstimation,proto3" json:"total_traffic_cost_estimation,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *CostEstimation) Reset() {
	*x = CostEstimation{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CostEstimation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CostEstimation) ProtoMessage() {}

func (x *CostEstimation) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CostEstimation.ProtoReflect.Descriptor instead.
func (*CostEstimation) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{1}
}

func (x *CostEstimation) GetEstimationTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.EstimationTimestamp
	}
	return nil
}

func (x *CostEstimation) GetConfirmationRequestTrafficCostEstimation() uint64 {
	if x != nil {
		return x.ConfirmationRequestTrafficCostEstimation
	}
	return 0
}

func (x *CostEstimation) GetConfirmationResponseTrafficCostEstimation() uint64 {
	if x != nil {
		return x.ConfirmationResponseTrafficCostEstimation
	}
	return 0
}

func (x *CostEstimation) GetTotalTrafficCostEstimation() uint64 {
	if x != nil {
		return x.TotalTrafficCostEstimation
	}
	return 0
}

type PrepareSubmissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Uniquely identifies the participant user that prepares the transaction.
	// Must be a valid UserIdString (as described in “value.proto“).
	// Required unless authentication is used with a user token.
	// In that case, the token's user-id will be used for the request's user_id.
	// Optional
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Uniquely identifies the command.
	// The triple (user_id, act_as, command_id) constitutes the change ID for the intended ledger change,
	// where act_as is interpreted as a set of party names.
	// The change ID can be used for matching the intended ledger changes with all their completions.
	// Must be a valid LedgerString (as described in “value.proto“).
	// Required
	CommandId string `protobuf:"bytes,2,opt,name=command_id,json=commandId,proto3" json:"command_id,omitempty"`
	// Individual elements of this atomic command. Must be non-empty.
	// Limitation: Only single command transaction are currently supported by the API.
	// The field is marked as repeated in preparation for future support of multiple commands.
	// Required
	Commands []*v2.Command `protobuf:"bytes,3,rep,name=commands,proto3" json:"commands,omitempty"`
	// Optional
	MinLedgerTime *MinLedgerTime `protobuf:"bytes,4,opt,name=min_ledger_time,json=minLedgerTime,proto3" json:"min_ledger_time,omitempty"`
	// Maximum timestamp at which the transaction can be recorded onto the ledger via the synchronizer specified in the `PrepareSubmissionResponse`.
	// If submitted after it will be rejected even if otherwise valid, in which case it needs to be prepared and signed again
	// with a new valid max_record_time.
	// Use this to limit the time-to-life of a prepared transaction,
	// which is useful to know when it can definitely not be accepted
	// anymore and resorting to preparing another transaction for the same
	// intent is safe again.
	// Optional
	MaxRecordTime *timestamppb.Timestamp `protobuf:"bytes,11,opt,name=max_record_time,json=maxRecordTime,proto3,oneof" json:"max_record_time,omitempty"`
	// Set of parties on whose behalf the command should be executed, if submitted.
	// If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
	// to **read** (not act) on behalf of each of the given parties. This is because this RPC merely prepares a transaction
	// and does not execute it. Therefore read authorization is sufficient even for actAs parties.
	// Note: This may change, and more specific authorization scope may be introduced in the future.
	// Each element must be a valid PartyIdString (as described in “value.proto“).
	// Required, must be non-empty.
	ActAs []string `protobuf:"bytes,5,rep,name=act_as,json=actAs,proto3" json:"act_as,omitempty"`
	// Set of parties on whose behalf (in addition to all parties listed in “act_as“) contracts can be retrieved.
	// This affects Daml operations such as “fetch“, “fetchByKey“, “lookupByKey“, “exercise“, and “exerciseByKey“.
	// Note: A command can only use contracts that are visible to at least
	// one of the parties in “act_as“ or “read_as“. This visibility check is independent from the Daml authorization
	// rules for fetch operations.
	// If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
	// to read contract data on behalf of each of the given parties.
	// Optional
	ReadAs []string `protobuf:"bytes,6,rep,name=read_as,json=readAs,proto3" json:"read_as,omitempty"`
	// Additional contracts used to resolve contract & contract key lookups.
	// Optional
	DisclosedContracts []*v2.DisclosedContract `protobuf:"bytes,7,rep,name=disclosed_contracts,json=disclosedContracts,proto3" json:"disclosed_contracts,omitempty"`
	// Must be a valid synchronizer id
	// If not set, a suitable synchronizer that this node is connected to will be chosen
	// Optional
	SynchronizerId string `protobuf:"bytes,8,opt,name=synchronizer_id,json=synchronizerId,proto3" json:"synchronizer_id,omitempty"`
	// The package-id selection preference of the client for resolving
	// package names and interface instances in command submission and interpretation
	// Optional
	PackageIdSelectionPreference []string `protobuf:"bytes,9,rep,name=package_id_selection_preference,json=packageIdSelectionPreference,proto3" json:"package_id_selection_preference,omitempty"`
	// When true, the response will contain additional details on how the transaction was encoded and hashed
	// This can be useful for troubleshooting of hash mismatches. Should only be used for debugging.
	// Optional, default to false
	VerboseHashing bool `protobuf:"varint,10,opt,name=verbose_hashing,json=verboseHashing,proto3" json:"verbose_hashing,omitempty"`
	// Fetches the contract keys into the caches to speed up the command processing.
	// Should only contain contract keys that are expected to be resolved during interpretation of the commands.
	// Keys of disclosed contracts do not need prefetching.
	//
	// Optional
	PrefetchContractKeys []*v2.PrefetchContractKey `protobuf:"bytes,15,rep,name=prefetch_contract_keys,json=prefetchContractKeys,proto3" json:"prefetch_contract_keys,omitempty"`
	// Hints to improve the accuracy of traffic cost estimation.
	// The estimation logic assumes that this node will be used for the execution of the transaction
	// If another node is used instead, the estimation may be less precise.
	// Request amplification is not accounted for in the estimation: each amplified request will
	// result in the cost of the confirmation request to be charged additionally.
	//
	// Optional - Traffic cost estimation is enabled by default if this field is not set
	// To turn off cost estimation, set the CostEstimationHints#disabled field to true
	EstimateTrafficCost *CostEstimationHints `protobuf:"bytes,16,opt,name=estimate_traffic_cost,json=estimateTrafficCost,proto3,oneof" json:"estimate_traffic_cost,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *PrepareSubmissionRequest) Reset() {
	*x = PrepareSubmissionRequest{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareSubmissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareSubmissionRequest) ProtoMessage() {}

func (x *PrepareSubmissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareSubmissionRequest.ProtoReflect.Descriptor instead.
func (*PrepareSubmissionRequest) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{2}
}

func (x *PrepareSubmissionRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *PrepareSubmissionRequest) GetCommandId() string {
	if x != nil {
		return x.CommandId
	}
	return ""
}

func (x *PrepareSubmissionRequest) GetCommands() []*v2.Command {
	if x != nil {
		return x.Commands
	}
	return nil
}

func (x *PrepareSubmissionRequest) GetMinLedgerTime() *MinLedgerTime {
	if x != nil {
		return x.MinLedgerTime
	}
	return nil
}

func (x *PrepareSubmissionRequest) GetMaxRecordTime() *timestamppb.Timestamp {
	if x != nil {
		return x.MaxRecordTime
	}
	return nil
}

func (x *PrepareSubmissionRequest) GetActAs() []string {
	if x != nil {
		return x.ActAs
	}
	return nil
}

func (x *PrepareSubmissionRequest) GetReadAs() []string {
	if x != nil {
		return x.ReadAs
	}
	return nil
}

func (x *PrepareSubmissionRequest) GetDisclosedContracts() []*v2.DisclosedContract {
	if x != nil {
		return x.DisclosedContracts
	}
	return nil
}

func (x *PrepareSubmissionRequest) GetSynchronizerId() string {
	if x != nil {
		return x.SynchronizerId
	}
	return ""
}

func (x *PrepareSubmissionRequest) GetPackageIdSelectionPreference() []string {
	if x != nil {
		return x.PackageIdSelectionPreference
	}
	return nil
}

func (x *PrepareSubmissionRequest) GetVerboseHashing() bool {
	if x != nil {
		return x.VerboseHashing
	}
	return false
}

func (x *PrepareSubmissionRequest) GetPrefetchContractKeys() []*v2.PrefetchContractKey {
	if x != nil {
		return x.PrefetchContractKeys
	}
	return nil
}

func (x *PrepareSubmissionRequest) GetEstimateTrafficCost() *CostEstimationHints {
	if x != nil {
		return x.EstimateTrafficCost
	}
	return nil
}

type PrepareSubmissionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The interpreted transaction, it represents the ledger changes necessary to execute the commands specified in the request.
	// Clients MUST display the content of the transaction to the user for them to validate before signing the hash if the preparing participant is not trusted.
	PreparedTransaction *PreparedTransaction `protobuf:"bytes,1,opt,name=prepared_transaction,json=preparedTransaction,proto3" json:"prepared_transaction,omitempty"`
	// Hash of the transaction, this is what needs to be signed by the party to authorize the transaction.
	// Only provided for convenience, clients MUST recompute the hash from the raw transaction if the preparing participant is not trusted.
	// May be removed in future versions
	PreparedTransactionHash []byte `protobuf:"bytes,2,opt,name=prepared_transaction_hash,json=preparedTransactionHash,proto3" json:"prepared_transaction_hash,omitempty"`
	// The hashing scheme version used when building the hash
	HashingSchemeVersion HashingSchemeVersion `protobuf:"varint,3,opt,name=hashing_scheme_version,json=hashingSchemeVersion,proto3,enum=com.daml.ledger.api.v2.interactive.HashingSchemeVersion" json:"hashing_scheme_version,omitempty"`
	// Optional additional details on how the transaction was encoded and hashed. Only set if verbose_hashing = true in the request
	// Note that there are no guarantees on the stability of the format or content of this field.
	// Its content should NOT be parsed and should only be used for troubleshooting purposes.
	HashingDetails *string `protobuf:"bytes,4,opt,name=hashing_details,json=hashingDetails,proto3,oneof" json:"hashing_details,omitempty"`
	// Traffic cost estimation of the prepared transaction
	// Optional
	CostEstimation *CostEstimation `protobuf:"bytes,5,opt,name=cost_estimation,json=costEstimation,proto3,oneof" json:"cost_estimation,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *PrepareSubmissionResponse) Reset() {
	*x = PrepareSubmissionResponse{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareSubmissionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareSubmissionResponse) ProtoMessage() {}

func (x *PrepareSubmissionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareSubmissionResponse.ProtoReflect.Descriptor instead.
func (*PrepareSubmissionResponse) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{3}
}

func (x *PrepareSubmissionResponse) GetPreparedTransaction() *PreparedTransaction {
	if x != nil {
		return x.PreparedTransaction
	}
	return nil
}

func (x *PrepareSubmissionResponse) GetPreparedTransactionHash() []byte {
	if x != nil {
		return x.PreparedTransactionHash
	}
	return nil
}

func (x *PrepareSubmissionResponse) GetHashingSchemeVersion() HashingSchemeVersion {
	if x != nil {
		return x.HashingSchemeVersion
	}
	return HashingSchemeVersion_HASHING_SCHEME_VERSION_UNSPECIFIED
}

func (x *PrepareSubmissionResponse) GetHashingDetails() string {
	if x != nil && x.HashingDetails != nil {
		return *x.HashingDetails
	}
	return ""
}

func (x *PrepareSubmissionResponse) GetCostEstimation() *CostEstimation {
	if x != nil {
		return x.CostEstimation
	}
	return nil
}

// Signatures provided by a single party
type SinglePartySignatures struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Submitting party
	// Required
	Party string `protobuf:"bytes,1,opt,name=party,proto3" json:"party,omitempty"`
	// Signatures
	// Required
	Signatures    []*v2.Signature `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SinglePartySignatures) Reset() {
	*x = SinglePartySignatures{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SinglePartySignatures) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SinglePartySignatures) ProtoMessage() {}

func (x *SinglePartySignatures) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SinglePartySignatures.ProtoReflect.Descriptor instead.
func (*SinglePartySignatures) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{4}
}

func (x *SinglePartySignatures) GetParty() string {
	if x != nil {
		return x.Party
	}
	return ""
}

func (x *SinglePartySignatures) GetSignatures() []*v2.Signature {
	if x != nil {
		return x.Signatures
	}
	return nil
}

// Additional signatures provided by the submitting parties
type PartySignatures struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Additional signatures provided by all individual parties
	// Required
	Signatures    []*SinglePartySignatures `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PartySignatures) Reset() {
	*x = PartySignatures{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartySignatures) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartySignatures) ProtoMessage() {}

func (x *PartySignatures) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartySignatures.ProtoReflect.Descriptor instead.
func (*PartySignatures) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{5}
}

func (x *PartySignatures) GetSignatures() []*SinglePartySignatures {
	if x != nil {
		return x.Signatures
	}
	return nil
}

type ExecuteSubmissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the prepared transaction
	// Typically this is the value of the `prepared_transaction` field in `PrepareSubmissionResponse`
	// obtained from calling `prepareSubmission`.
	// Required
	PreparedTransaction *PreparedTransaction `protobuf:"bytes,1,opt,name=prepared_transaction,json=preparedTransaction,proto3" json:"prepared_transaction,omitempty"`
	// The party(ies) signatures that authorize the prepared submission to be executed by this node.
	// Each party can provide one or more signatures..
	// and one or more parties can sign.
	// Note that currently, only single party submissions are supported.
	// Required
	PartySignatures *PartySignatures `protobuf:"bytes,2,opt,name=party_signatures,json=partySignatures,proto3" json:"party_signatures,omitempty"`
	// Specifies the deduplication period for the change ID (See PrepareSubmissionRequest).
	// If omitted, the participant will assume the configured maximum deduplication time.
	// Optional
	//
	// Types that are valid to be assigned to DeduplicationPeriod:
	//
	//	*ExecuteSubmissionRequest_DeduplicationDuration
	//	*ExecuteSubmissionRequest_DeduplicationOffset
	DeduplicationPeriod isExecuteSubmissionRequest_DeduplicationPeriod `protobuf_oneof:"deduplication_period"`
	// A unique identifier to distinguish completions for different submissions with the same change ID.
	// Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
	// with the same change ID.
	// Must be a valid LedgerString (as described in “value.proto“).
	//
	// Required
	SubmissionId string `protobuf:"bytes,5,opt,name=submission_id,json=submissionId,proto3" json:"submission_id,omitempty"`
	// See [PrepareSubmissionRequest.user_id]
	// Optional
	UserId string `protobuf:"bytes,6,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// The hashing scheme version used when building the hash
	// Required
	HashingSchemeVersion HashingSchemeVersion `protobuf:"varint,7,opt,name=hashing_scheme_version,json=hashingSchemeVersion,proto3,enum=com.daml.ledger.api.v2.interactive.HashingSchemeVersion" json:"hashing_scheme_version,omitempty"`
	// If set will influence the chosen ledger effective time but will not result in a submission delay so any override
	// should be scheduled to executed within the window allowed by synchronizer.
	// Optional
	MinLedgerTime *MinLedgerTime `protobuf:"bytes,8,opt,name=min_ledger_time,json=minLedgerTime,proto3" json:"min_ledger_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteSubmissionRequest) Reset() {
	*x = ExecuteSubmissionRequest{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteSubmissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteSubmissionRequest) ProtoMessage() {}

func (x *ExecuteSubmissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteSubmissionRequest.ProtoReflect.Descriptor instead.
func (*ExecuteSubmissionRequest) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{6}
}

func (x *ExecuteSubmissionRequest) GetPreparedTransaction() *PreparedTransaction {
	if x != nil {
		return x.PreparedTransaction
	}
	return nil
}

func (x *ExecuteSubmissionRequest) GetPartySignatures() *PartySignatures {
	if x != nil {
		return x.PartySignatures
	}
	return nil
}

func (x *ExecuteSubmissionRequest) GetDeduplicationPeriod() isExecuteSubmissionRequest_DeduplicationPeriod {
	if x != nil {
		return x.DeduplicationPeriod
	}
	return nil
}

func (x *ExecuteSubmissionRequest) GetDeduplicationDuration() *durationpb.Duration {
	if x != nil {
		if x, ok := x.DeduplicationPeriod.(*ExecuteSubmissionRequest_DeduplicationDuration); ok {
			return x.DeduplicationDuration
		}
	}
	return nil
}

func (x *ExecuteSubmissionRequest) GetDeduplicationOffset() int64 {
	if x != nil {
		if x, ok := x.DeduplicationPeriod.(*ExecuteSubmissionRequest_DeduplicationOffset); ok {
			return x.DeduplicationOffset
		}
	}
	return 0
}

func (x *ExecuteSubmissionRequest) GetSubmissionId() string {
	if x != nil {
		return x.SubmissionId
	}
	return ""
}

func (x *ExecuteSubmissionRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *ExecuteSubmissionRequest) GetHashingSchemeVersion() HashingSchemeVersion {
	if x != nil {
		return x.HashingSchemeVersion
	}
	return HashingSchemeVersion_HASHING_SCHEME_VERSION_UNSPECIFIED
}

func (x *ExecuteSubmissionRequest) GetMinLedgerTime() *MinLedgerTime {
	if x != nil {
		return x.MinLedgerTime
	}
	return nil
}

type isExecuteSubmissionRequest_DeduplicationPeriod interface {
	isExecuteSubmissionRequest_DeduplicationPeriod()
}

type ExecuteSubmissionRequest_DeduplicationDuration struct {
	// Specifies the length of the deduplication period.
	// It is interpreted relative to the local clock at some point during the submission's processing.
	// Must be non-negative. Must not exceed the maximum deduplication time.
	DeduplicationDuration *durationpb.Duration `protobuf:"bytes,3,opt,name=deduplication_duration,json=deduplicationDuration,proto3,oneof"`
}

type ExecuteSubmissionRequest_DeduplicationOffset struct {
	// Specifies the start of the deduplication period by a completion stream offset (exclusive).
	// Must be a valid absolute offset (positive integer).
	DeduplicationOffset int64 `protobuf:"varint,4,opt,name=deduplication_offset,json=deduplicationOffset,proto3,oneof"`
}

func (*ExecuteSubmissionRequest_DeduplicationDuration) isExecuteSubmissionRequest_DeduplicationPeriod() {
}

func (*ExecuteSubmissionRequest_DeduplicationOffset) isExecuteSubmissionRequest_DeduplicationPeriod() {
}

type ExecuteSubmissionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteSubmissionResponse) Reset() {
	*x = ExecuteSubmissionResponse{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteSubmissionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteSubmissionResponse) ProtoMessage() {}

func (x *ExecuteSubmissionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteSubmissionResponse.ProtoReflect.Descriptor instead.
func (*ExecuteSubmissionResponse) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{7}
}

type ExecuteSubmissionAndWaitRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the prepared transaction
	// Typically this is the value of the `prepared_transaction` field in `PrepareSubmissionResponse`
	// obtained from calling `prepareSubmission`.
	// Required
	PreparedTransaction *PreparedTransaction `protobuf:"bytes,1,opt,name=prepared_transaction,json=preparedTransaction,proto3" json:"prepared_transaction,omitempty"`
	// The party(ies) signatures that authorize the prepared submission to be executed by this node.
	// Each party can provide one or more signatures..
	// and one or more parties can sign.
	// Note that currently, only single party submissions are supported.
	// Required
	PartySignatures *PartySignatures `protobuf:"bytes,2,opt,name=party_signatures,json=partySignatures,proto3" json:"party_signatures,omitempty"`
	// Specifies the deduplication period for the change ID (See PrepareSubmissionRequest).
	// If omitted, the participant will assume the configured maximum deduplication time.
	// Optional
	//
	// Types that are valid to be assigned to DeduplicationPeriod:
	//
	//	*ExecuteSubmissionAndWaitRequest_DeduplicationDuration
	//	*ExecuteSubmissionAndWaitRequest_DeduplicationOffset
	DeduplicationPeriod isExecuteSubmissionAndWaitRequest_DeduplicationPeriod `protobuf_oneof:"deduplication_period"`
	// A unique identifier to distinguish completions for different submissions with the same change ID.
	// Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
	// with the same change ID.
	// Must be a valid LedgerString (as described in “value.proto“).
	//
	// Required
	SubmissionId string `protobuf:"bytes,5,opt,name=submission_id,json=submissionId,proto3" json:"submission_id,omitempty"`
	// See [PrepareSubmissionRequest.user_id]
	// Optional
	UserId string `protobuf:"bytes,6,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// The hashing scheme version used when building the hash
	// Required
	HashingSchemeVersion HashingSchemeVersion `protobuf:"varint,7,opt,name=hashing_scheme_version,json=hashingSchemeVersion,proto3,enum=com.daml.ledger.api.v2.interactive.HashingSchemeVersion" json:"hashing_scheme_version,omitempty"`
	// If set will influence the chosen ledger effective time but will not result in a submission delay so any override
	// should be scheduled to executed within the window allowed by synchronizer.
	// Optional
	MinLedgerTime *MinLedgerTime `protobuf:"bytes,8,opt,name=min_ledger_time,json=minLedgerTime,proto3" json:"min_ledger_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteSubmissionAndWaitRequest) Reset() {
	*x = ExecuteSubmissionAndWaitRequest{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteSubmissionAndWaitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteSubmissionAndWaitRequest) ProtoMessage() {}

func (x *ExecuteSubmissionAndWaitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteSubmissionAndWaitRequest.ProtoReflect.Descriptor instead.
func (*ExecuteSubmissionAndWaitRequest) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{8}
}

func (x *ExecuteSubmissionAndWaitRequest) GetPreparedTransaction() *PreparedTransaction {
	if x != nil {
		return x.PreparedTransaction
	}
	return nil
}

func (x *ExecuteSubmissionAndWaitRequest) GetPartySignatures() *PartySignatures {
	if x != nil {
		return x.PartySignatures
	}
	return nil
}

func (x *ExecuteSubmissionAndWaitRequest) GetDeduplicationPeriod() isExecuteSubmissionAndWaitRequest_DeduplicationPeriod {
	if x != nil {
		return x.DeduplicationPeriod
	}
	return nil
}

func (x *ExecuteSubmissionAndWaitRequest) GetDeduplicationDuration() *durationpb.Duration {
	if x != nil {
		if x, ok := x.DeduplicationPeriod.(*ExecuteSubmissionAndWaitRequest_DeduplicationDuration); ok {
			return x.DeduplicationDuration
		}
	}
	return nil
}

func (x *ExecuteSubmissionAndWaitRequest) GetDeduplicationOffset() int64 {
	if x != nil {
		if x, ok := x.DeduplicationPeriod.(*ExecuteSubmissionAndWaitRequest_DeduplicationOffset); ok {
			return x.DeduplicationOffset
		}
	}
	return 0
}

func (x *ExecuteSubmissionAndWaitRequest) GetSubmissionId() string {
	if x != nil {
		return x.SubmissionId
	}
	return ""
}

func (x *ExecuteSubmissionAndWaitRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *ExecuteSubmissionAndWaitRequest) GetHashingSchemeVersion() HashingSchemeVersion {
	if x != nil {
		return x.HashingSchemeVersion
	}
	return HashingSchemeVersion_HASHING_SCHEME_VERSION_UNSPECIFIED
}

func (x *ExecuteSubmissionAndWaitRequest) GetMinLedgerTime() *MinLedgerTime {
	if x != nil {
		return x.MinLedgerTime
	}
	return nil
}

type isExecuteSubmissionAndWaitRequest_DeduplicationPeriod interface {
	isExecuteSubmissionAndWaitRequest_DeduplicationPeriod()
}

type ExecuteSubmissionAndWaitRequest_DeduplicationDuration struct {
	// Specifies the length of the deduplication period.
	// It is interpreted relative to the local clock at some point during the submission's processing.
	// Must be non-negative. Must not exceed the maximum deduplication time.
	DeduplicationDuration *durationpb.Duration `protobuf:"bytes,3,opt,name=deduplication_duration,json=deduplicationDuration,proto3,oneof"`
}

type ExecuteSubmissionAndWaitRequest_DeduplicationOffset struct {
	// Specifies the start of the deduplication period by a completion stream offset (exclusive).
	// Must be a valid absolute offset (positive integer).
	DeduplicationOffset int64 `protobuf:"varint,4,opt,name=deduplication_offset,json=deduplicationOffset,proto3,oneof"`
}

func (*ExecuteSubmissionAndWaitRequest_DeduplicationDuration) isExecuteSubmissionAndWaitRequest_DeduplicationPeriod() {
}

func (*ExecuteSubmissionAndWaitRequest_DeduplicationOffset) isExecuteSubmissionAndWaitRequest_DeduplicationPeriod() {
}

type ExecuteSubmissionAndWaitResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the transaction that resulted from the submitted command.
	// Must be a valid LedgerString (as described in “value.proto“).
	// Required
	UpdateId string `protobuf:"bytes,1,opt,name=update_id,json=updateId,proto3" json:"update_id,omitempty"`
	// The details of the offset field are described in “community/ledger-api/README.md“.
	// Required
	CompletionOffset int64 `protobuf:"varint,2,opt,name=completion_offset,json=completionOffset,proto3" json:"completion_offset,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ExecuteSubmissionAndWaitResponse) Reset() {
	*x = ExecuteSubmissionAndWaitResponse{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteSubmissionAndWaitResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteSubmissionAndWaitResponse) ProtoMessage() {}

func (x *ExecuteSubmissionAndWaitResponse) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteSubmissionAndWaitResponse.ProtoReflect.Descriptor instead.
func (*ExecuteSubmissionAndWaitResponse) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{9}
}

func (x *ExecuteSubmissionAndWaitResponse) GetUpdateId() string {
	if x != nil {
		return x.UpdateId
	}
	return ""
}

func (x *ExecuteSubmissionAndWaitResponse) GetCompletionOffset() int64 {
	if x != nil {
		return x.CompletionOffset
	}
	return 0
}

type ExecuteSubmissionAndWaitForTransactionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the prepared transaction
	// Typically this is the value of the `prepared_transaction` field in `PrepareSubmissionResponse`
	// obtained from calling `prepareSubmission`.
	// Required
	PreparedTransaction *PreparedTransaction `protobuf:"bytes,1,opt,name=prepared_transaction,json=preparedTransaction,proto3" json:"prepared_transaction,omitempty"`
	// The party(ies) signatures that authorize the prepared submission to be executed by this node.
	// Each party can provide one or more signatures..
	// and one or more parties can sign.
	// Note that currently, only single party submissions are supported.
	// Required
	PartySignatures *PartySignatures `protobuf:"bytes,2,opt,name=party_signatures,json=partySignatures,proto3" json:"party_signatures,omitempty"`
	// Specifies the deduplication period for the change ID (See PrepareSubmissionRequest).
	// If omitted, the participant will assume the configured maximum deduplication time.
	// Optional
	//
	// Types that are valid to be assigned to DeduplicationPeriod:
	//
	//	*ExecuteSubmissionAndWaitForTransactionRequest_DeduplicationDuration
	//	*ExecuteSubmissionAndWaitForTransactionRequest_DeduplicationOffset
	DeduplicationPeriod isExecuteSubmissionAndWaitForTransactionRequest_DeduplicationPeriod `protobuf_oneof:"deduplication_period"`
	// A unique identifier to distinguish completions for different submissions with the same change ID.
	// Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
	// with the same change ID.
	// Must be a valid LedgerString (as described in “value.proto“).
	//
	// Required
	SubmissionId string `protobuf:"bytes,5,opt,name=submission_id,json=submissionId,proto3" json:"submission_id,omitempty"`
	// See [PrepareSubmissionRequest.user_id]
	// Optional
	UserId string `protobuf:"bytes,6,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// The hashing scheme version used when building the hash
	// Required
	HashingSchemeVersion HashingSchemeVersion `protobuf:"varint,7,opt,name=hashing_scheme_version,json=hashingSchemeVersion,proto3,enum=com.daml.ledger.api.v2.interactive.HashingSchemeVersion" json:"hashing_scheme_version,omitempty"`
	// If set will influence the chosen ledger effective time but will not result in a submission delay so any override
	// should be scheduled to executed within the window allowed by synchronizer.
	// Optional
	MinLedgerTime *MinLedgerTime `protobuf:"bytes,8,opt,name=min_ledger_time,json=minLedgerTime,proto3" json:"min_ledger_time,omitempty"`
	// If no “transaction_format“ is provided, a default will be used where “transaction_shape“ is set to
	// TRANSACTION_SHAPE_ACS_DELTA, “event_format“ is defined with “filters_by_party“ containing wildcard-template
	// filter for all original “act_as“ and “read_as“ parties and the “verbose“ flag is set.
	// When the “transaction_shape“ TRANSACTION_SHAPE_ACS_DELTA shape is used (explicitly or is defaulted to as explained above),
	// events will only be returned if the submitting party is hosted on this node.
	// Optional
	TransactionFormat *v2.TransactionFormat `protobuf:"bytes,9,opt,name=transaction_format,json=transactionFormat,proto3" json:"transaction_format,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ExecuteSubmissionAndWaitForTransactionRequest) Reset() {
	*x = ExecuteSubmissionAndWaitForTransactionRequest{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteSubmissionAndWaitForTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteSubmissionAndWaitForTransactionRequest) ProtoMessage() {}

func (x *ExecuteSubmissionAndWaitForTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteSubmissionAndWaitForTransactionRequest.ProtoReflect.Descriptor instead.
func (*ExecuteSubmissionAndWaitForTransactionRequest) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{10}
}

func (x *ExecuteSubmissionAndWaitForTransactionRequest) GetPreparedTransaction() *PreparedTransaction {
	if x != nil {
		return x.PreparedTransaction
	}
	return nil
}

func (x *ExecuteSubmissionAndWaitForTransactionRequest) GetPartySignatures() *PartySignatures {
	if x != nil {
		return x.PartySignatures
	}
	return nil
}

func (x *ExecuteSubmissionAndWaitForTransactionRequest) GetDeduplicationPeriod() isExecuteSubmissionAndWaitForTransactionRequest_DeduplicationPeriod {
	if x != nil {
		return x.DeduplicationPeriod
	}
	return nil
}

func (x *ExecuteSubmissionAndWaitForTransactionRequest) GetDeduplicationDuration() *durationpb.Duration {
	if x != nil {
		if x, ok := x.DeduplicationPeriod.(*ExecuteSubmissionAndWaitForTransactionRequest_DeduplicationDuration); ok {
			return x.DeduplicationDuration
		}
	}
	return nil
}

func (x *ExecuteSubmissionAndWaitForTransactionRequest) GetDeduplicationOffset() int64 {
	if x != nil {
		if x, ok := x.DeduplicationPeriod.(*ExecuteSubmissionAndWaitForTransactionRequest_DeduplicationOffset); ok {
			return x.DeduplicationOffset
		}
	}
	return 0
}

func (x *ExecuteSubmissionAndWaitForTransactionRequest) GetSubmissionId() string {
	if x != nil {
		return x.SubmissionId
	}
	return ""
}

func (x *ExecuteSubmissionAndWaitForTransactionRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *ExecuteSubmissionAndWaitForTransactionRequest) GetHashingSchemeVersion() HashingSchemeVersion {
	if x != nil {
		return x.HashingSchemeVersion
	}
	return HashingSchemeVersion_HASHING_SCHEME_VERSION_UNSPECIFIED
}

func (x *ExecuteSubmissionAndWaitForTransactionRequest) GetMinLedgerTime() *MinLedgerTime {
	if x != nil {
		return x.MinLedgerTime
	}
	return nil
}

func (x *ExecuteSubmissionAndWaitForTransactionRequest) GetTransactionFormat() *v2.TransactionFormat {
	if x != nil {
		return x.TransactionFormat
	}
	return nil
}

type isExecuteSubmissionAndWaitForTransactionRequest_DeduplicationPeriod interface {
	isExecuteSubmissionAndWaitForTransactionRequest_DeduplicationPeriod()
}

type ExecuteSubmissionAndWaitForTransactionRequest_DeduplicationDuration struct {
	// Specifies the length of the deduplication period.
	// It is interpreted relative to the local clock at some point during the submission's processing.
	// Must be non-negative. Must not exceed the maximum deduplication time.
	DeduplicationDuration *durationpb.Duration `protobuf:"bytes,3,opt,name=deduplication_duration,json=deduplicationDuration,proto3,oneof"`
}

type ExecuteSubmissionAndWaitForTransactionRequest_DeduplicationOffset struct {
	// Specifies the start of the deduplication period by a completion stream offset (exclusive).
	// Must be a valid absolute offset (positive integer).
	DeduplicationOffset int64 `protobuf:"varint,4,opt,name=deduplication_offset,json=deduplicationOffset,proto3,oneof"`
}

func (*ExecuteSubmissionAndWaitForTransactionRequest_DeduplicationDuration) isExecuteSubmissionAndWaitForTransactionRequest_DeduplicationPeriod() {
}

func (*ExecuteSubmissionAndWaitForTransactionRequest_DeduplicationOffset) isExecuteSubmissionAndWaitForTransactionRequest_DeduplicationPeriod() {
}

type ExecuteSubmissionAndWaitForTransactionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The transaction that resulted from the submitted command.
	// The transaction might contain no events (request conditions result in filtering out all of them).
	// Required
	Transaction   *v2.Transaction `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteSubmissionAndWaitForTransactionResponse) Reset() {
	*x = ExecuteSubmissionAndWaitForTransactionResponse{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteSubmissionAndWaitForTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteSubmissionAndWaitForTransactionResponse) ProtoMessage() {}

func (x *ExecuteSubmissionAndWaitForTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteSubmissionAndWaitForTransactionResponse.ProtoReflect.Descriptor instead.
func (*ExecuteSubmissionAndWaitForTransactionResponse) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{11}
}

func (x *ExecuteSubmissionAndWaitForTransactionResponse) GetTransaction() *v2.Transaction {
	if x != nil {
		return x.Transaction
	}
	return nil
}

type MinLedgerTime struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Time:
	//
	//	*MinLedgerTime_MinLedgerTimeAbs
	//	*MinLedgerTime_MinLedgerTimeRel
	Time          isMinLedgerTime_Time `protobuf_oneof:"time"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MinLedgerTime) Reset() {
	*x = MinLedgerTime{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MinLedgerTime) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MinLedgerTime) ProtoMessage() {}

func (x *MinLedgerTime) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MinLedgerTime.ProtoReflect.Descriptor instead.
func (*MinLedgerTime) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{12}
}

func (x *MinLedgerTime) GetTime() isMinLedgerTime_Time {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *MinLedgerTime) GetMinLedgerTimeAbs() *timestamppb.Timestamp {
	if x != nil {
		if x, ok := x.Time.(*MinLedgerTime_MinLedgerTimeAbs); ok {
			return x.MinLedgerTimeAbs
		}
	}
	return nil
}

func (x *MinLedgerTime) GetMinLedgerTimeRel() *durationpb.Duration {
	if x != nil {
		if x, ok := x.Time.(*MinLedgerTime_MinLedgerTimeRel); ok {
			return x.MinLedgerTimeRel
		}
	}
	return nil
}

type isMinLedgerTime_Time interface {
	isMinLedgerTime_Time()
}

type MinLedgerTime_MinLedgerTimeAbs struct {
	// Lower bound for the ledger time assigned to the resulting transaction.
	// The ledger time of a transaction is assigned as part of command interpretation.
	// Important note: for interactive submissions, if the transaction depends on time, it **must** be signed
	// and submitted within a time window around the ledger time assigned to the transaction during the prepare method.
	// The time delta around that ledger time is a configuration of the ledger, usually short, around 1 minute.
	// If however the transaction does not depend on time, the available time window to sign and submit the transaction is bound
	// by the preparation time, which is also assigned in the "prepare" step (this request),
	// but can be configured with a much larger skew, allowing for more time to sign the request (in the order of hours).
	// Must not be set at the same time as min_ledger_time_rel.
	// Optional
	MinLedgerTimeAbs *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=min_ledger_time_abs,json=minLedgerTimeAbs,proto3,oneof"`
}

type MinLedgerTime_MinLedgerTimeRel struct {
	// Same as min_ledger_time_abs, but specified as a duration, starting from the time this request is received by the server.
	// Must not be set at the same time as min_ledger_time_abs.
	// Optional
	MinLedgerTimeRel *durationpb.Duration `protobuf:"bytes,2,opt,name=min_ledger_time_rel,json=minLedgerTimeRel,proto3,oneof"`
}

func (*MinLedgerTime_MinLedgerTimeAbs) isMinLedgerTime_Time() {}

func (*MinLedgerTime_MinLedgerTimeRel) isMinLedgerTime_Time() {}

// *
// Prepared Transaction Message
type PreparedTransaction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Daml Transaction representing the ledger effect if executed. See below
	Transaction *DamlTransaction `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
	// Metadata context necessary to execute the transaction
	Metadata      *Metadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PreparedTransaction) Reset() {
	*x = PreparedTransaction{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PreparedTransaction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PreparedTransaction) ProtoMessage() {}

func (x *PreparedTransaction) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PreparedTransaction.ProtoReflect.Descriptor instead.
func (*PreparedTransaction) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{13}
}

func (x *PreparedTransaction) GetTransaction() *DamlTransaction {
	if x != nil {
		return x.Transaction
	}
	return nil
}

func (x *PreparedTransaction) GetMetadata() *Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// Transaction Metadata
// Refer to the hashing documentation for information on how it should be hashed.
type Metadata struct {
	state           protoimpl.MessageState    `protogen:"open.v1"`
	SubmitterInfo   *Metadata_SubmitterInfo   `protobuf:"bytes,2,opt,name=submitter_info,json=submitterInfo,proto3" json:"submitter_info,omitempty"`
	SynchronizerId  string                    `protobuf:"bytes,3,opt,name=synchronizer_id,json=synchronizerId,proto3" json:"synchronizer_id,omitempty"`
	MediatorGroup   uint32                    `protobuf:"varint,4,opt,name=mediator_group,json=mediatorGroup,proto3" json:"mediator_group,omitempty"`
	TransactionUuid string                    `protobuf:"bytes,5,opt,name=transaction_uuid,json=transactionUuid,proto3" json:"transaction_uuid,omitempty"`
	PreparationTime uint64                    `protobuf:"varint,6,opt,name=preparation_time,json=preparationTime,proto3" json:"preparation_time,omitempty"`
	InputContracts  []*Metadata_InputContract `protobuf:"bytes,7,rep,name=input_contracts,json=inputContracts,proto3" json:"input_contracts,omitempty"`
	// Where ledger time constraints are imposed during the execution of the contract they will be populated
	// in the fields below. These are optional because if the transaction does NOT depend on time, these values
	// do not need to be set.
	// The final ledger effective time used will be chosen when the command is submitted through the [execute] RPC.
	// If the ledger effective time is outside of any populated min/max bounds then a different transaction
	// can result, that will cause a confirmation message rejection.
	MinLedgerEffectiveTime *uint64 `protobuf:"varint,9,opt,name=min_ledger_effective_time,json=minLedgerEffectiveTime,proto3,oneof" json:"min_ledger_effective_time,omitempty"`
	MaxLedgerEffectiveTime *uint64 `protobuf:"varint,10,opt,name=max_ledger_effective_time,json=maxLedgerEffectiveTime,proto3,oneof" json:"max_ledger_effective_time,omitempty"`
	// Contextual information needed to process the transaction but not signed, either because it's already indirectly
	// signed by signing the transaction, or because it doesn't impact the ledger state
	GlobalKeyMapping []*Metadata_GlobalKeyMappingEntry `protobuf:"bytes,8,rep,name=global_key_mapping,json=globalKeyMapping,proto3" json:"global_key_mapping,omitempty"`
	// Maximum timestamp at which the transaction can be recorded onto the ledger via the synchronizer `synchronizer_id`.
	// If submitted after it will be rejected even if otherwise valid, in which case it needs to be prepared and signed again
	// with a new valid max_record_time.
	// Unsigned in 3.3 to avoid a breaking protocol change
	// Will be signed in 3.4+
	// Set max_record_time in the PreparedTransactionRequest to get this field set accordingly
	MaxRecordTime *uint64 `protobuf:"varint,11,opt,name=max_record_time,json=maxRecordTime,proto3,oneof" json:"max_record_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Metadata) Reset() {
	*x = Metadata{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Metadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Metadata) ProtoMessage() {}

func (x *Metadata) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Metadata.ProtoReflect.Descriptor instead.
func (*Metadata) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{14}
}

func (x *Metadata) GetSubmitterInfo() *Metadata_SubmitterInfo {
	if x != nil {
		return x.SubmitterInfo
	}
	return nil
}

func (x *Metadata) GetSynchronizerId() string {
	if x != nil {
		return x.SynchronizerId
	}
	return ""
}

func (x *Metadata) GetMediatorGroup() uint32 {
	if x != nil {
		return x.MediatorGroup
	}
	return 0
}

func (x *Metadata) GetTransactionUuid() string {
	if x != nil {
		return x.TransactionUuid
	}
	return ""
}

func (x *Metadata) GetPreparationTime() uint64 {
	if x != nil {
		return x.PreparationTime
	}
	return 0
}

func (x *Metadata) GetInputContracts() []*Metadata_InputContract {
	if x != nil {
		return x.InputContracts
	}
	return nil
}

func (x *Metadata) GetMinLedgerEffectiveTime() uint64 {
	if x != nil && x.MinLedgerEffectiveTime != nil {
		return *x.MinLedgerEffectiveTime
	}
	return 0
}

func (x *Metadata) GetMaxLedgerEffectiveTime() uint64 {
	if x != nil && x.MaxLedgerEffectiveTime != nil {
		return *x.MaxLedgerEffectiveTime
	}
	return 0
}

func (x *Metadata) GetGlobalKeyMapping() []*Metadata_GlobalKeyMappingEntry {
	if x != nil {
		return x.GlobalKeyMapping
	}
	return nil
}

func (x *Metadata) GetMaxRecordTime() uint64 {
	if x != nil && x.MaxRecordTime != nil {
		return *x.MaxRecordTime
	}
	return 0
}

// Daml Transaction.
// This represents the effect on the ledger if this transaction is successfully committed.
type DamlTransaction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// serialization version, will be >= max(nodes version)
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Root nodes of the transaction
	Roots []string `protobuf:"bytes,2,rep,name=roots,proto3" json:"roots,omitempty"`
	// List of nodes in the transaction
	Nodes []*DamlTransaction_Node `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// Node seeds are values associated with certain nodes used for generating cryptographic salts
	NodeSeeds     []*DamlTransaction_NodeSeed `protobuf:"bytes,4,rep,name=node_seeds,json=nodeSeeds,proto3" json:"node_seeds,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DamlTransaction) Reset() {
	*x = DamlTransaction{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DamlTransaction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DamlTransaction) ProtoMessage() {}

func (x *DamlTransaction) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DamlTransaction.ProtoReflect.Descriptor instead.
func (*DamlTransaction) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{15}
}

func (x *DamlTransaction) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *DamlTransaction) GetRoots() []string {
	if x != nil {
		return x.Roots
	}
	return nil
}

func (x *DamlTransaction) GetNodes() []*DamlTransaction_Node {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *DamlTransaction) GetNodeSeeds() []*DamlTransaction_NodeSeed {
	if x != nil {
		return x.NodeSeeds
	}
	return nil
}

type GetPreferredPackageVersionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The parties whose participants' vetting state should be considered when resolving the preferred package.
	// Required
	Parties []string `protobuf:"bytes,1,rep,name=parties,proto3" json:"parties,omitempty"`
	// The package-name for which the preferred package should be resolved.
	// Required
	PackageName string `protobuf:"bytes,2,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	// The synchronizer whose vetting state should be used for resolving this query.
	// If not specified, the vetting states of all synchronizers to which the participant is connected are used.
	// Optional
	SynchronizerId string `protobuf:"bytes,3,opt,name=synchronizer_id,json=synchronizerId,proto3" json:"synchronizer_id,omitempty"`
	// The timestamp at which the package vetting validity should be computed
	// on the latest topology snapshot as seen by the participant.
	// If not provided, the participant's current clock time is used.
	// Optional
	VettingValidAt *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=vetting_valid_at,json=vettingValidAt,proto3" json:"vetting_valid_at,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GetPreferredPackageVersionRequest) Reset() {
	*x = GetPreferredPackageVersionRequest{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPreferredPackageVersionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPreferredPackageVersionRequest) ProtoMessage() {}

func (x *GetPreferredPackageVersionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPreferredPackageVersionRequest.ProtoReflect.Descriptor instead.
func (*GetPreferredPackageVersionRequest) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{16}
}

func (x *GetPreferredPackageVersionRequest) GetParties() []string {
	if x != nil {
		return x.Parties
	}
	return nil
}

func (x *GetPreferredPackageVersionRequest) GetPackageName() string {
	if x != nil {
		return x.PackageName
	}
	return ""
}

func (x *GetPreferredPackageVersionRequest) GetSynchronizerId() string {
	if x != nil {
		return x.SynchronizerId
	}
	return ""
}

func (x *GetPreferredPackageVersionRequest) GetVettingValidAt() *timestamppb.Timestamp {
	if x != nil {
		return x.VettingValidAt
	}
	return nil
}

type GetPreferredPackageVersionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Not populated when no preferred package is found
	// Optional
	PackagePreference *PackagePreference `protobuf:"bytes,1,opt,name=package_preference,json=packagePreference,proto3" json:"package_preference,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GetPreferredPackageVersionResponse) Reset() {
	*x = GetPreferredPackageVersionResponse{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPreferredPackageVersionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPreferredPackageVersionResponse) ProtoMessage() {}

func (x *GetPreferredPackageVersionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPreferredPackageVersionResponse.ProtoReflect.Descriptor instead.
func (*GetPreferredPackageVersionResponse) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{17}
}

func (x *GetPreferredPackageVersionResponse) GetPackagePreference() *PackagePreference {
	if x != nil {
		return x.PackagePreference
	}
	return nil
}

type PackagePreference struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The package reference of the preferred package.
	// Required
	PackageReference *v2.PackageReference `protobuf:"bytes,1,opt,name=package_reference,json=packageReference,proto3" json:"package_reference,omitempty"`
	// The synchronizer for which the preferred package was computed.
	// If the synchronizer_id was specified in the request, then it matches the request synchronizer_id.
	// Required
	SynchronizerId string `protobuf:"bytes,2,opt,name=synchronizer_id,json=synchronizerId,proto3" json:"synchronizer_id,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *PackagePreference) Reset() {
	*x = PackagePreference{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PackagePreference) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PackagePreference) ProtoMessage() {}

func (x *PackagePreference) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PackagePreference.ProtoReflect.Descriptor instead.
func (*PackagePreference) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{18}
}

func (x *PackagePreference) GetPackageReference() *v2.PackageReference {
	if x != nil {
		return x.PackageReference
	}
	return nil
}

func (x *PackagePreference) GetSynchronizerId() string {
	if x != nil {
		return x.SynchronizerId
	}
	return ""
}

// Defines a package-name for which the commonly vetted package with the highest version must be found.
type PackageVettingRequirement struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The parties whose participants' vetting state should be considered when resolving the preferred package.
	// Required
	Parties []string `protobuf:"bytes,1,rep,name=parties,proto3" json:"parties,omitempty"`
	// The package-name for which the preferred package should be resolved.
	// Required
	PackageName   string `protobuf:"bytes,2,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PackageVettingRequirement) Reset() {
	*x = PackageVettingRequirement{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PackageVettingRequirement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PackageVettingRequirement) ProtoMessage() {}

func (x *PackageVettingRequirement) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PackageVettingRequirement.ProtoReflect.Descriptor instead.
func (*PackageVettingRequirement) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{19}
}

func (x *PackageVettingRequirement) GetParties() []string {
	if x != nil {
		return x.Parties
	}
	return nil
}

func (x *PackageVettingRequirement) GetPackageName() string {
	if x != nil {
		return x.PackageName
	}
	return ""
}

type GetPreferredPackagesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The package-name vetting requirements for which the preferred packages should be resolved.
	//
	// Generally it is enough to provide the requirements for the intended command's root package-names.
	// Additional package-name requirements can be provided when additional Daml transaction informees need to use
	// package dependencies of the command's root packages.
	//
	// Required
	PackageVettingRequirements []*PackageVettingRequirement `protobuf:"bytes,1,rep,name=package_vetting_requirements,json=packageVettingRequirements,proto3" json:"package_vetting_requirements,omitempty"`
	// The synchronizer whose vetting state should be used for resolving this query.
	// If not specified, the vetting states of all synchronizers to which the participant is connected are used.
	// Optional
	SynchronizerId string `protobuf:"bytes,2,opt,name=synchronizer_id,json=synchronizerId,proto3" json:"synchronizer_id,omitempty"`
	// The timestamp at which the package vetting validity should be computed
	// on the latest topology snapshot as seen by the participant.
	// If not provided, the participant's current clock time is used.
	// Optional
	VettingValidAt *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=vetting_valid_at,json=vettingValidAt,proto3" json:"vetting_valid_at,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GetPreferredPackagesRequest) Reset() {
	*x = GetPreferredPackagesRequest{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPreferredPackagesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPreferredPackagesRequest) ProtoMessage() {}

func (x *GetPreferredPackagesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPreferredPackagesRequest.ProtoReflect.Descriptor instead.
func (*GetPreferredPackagesRequest) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{20}
}

func (x *GetPreferredPackagesRequest) GetPackageVettingRequirements() []*PackageVettingRequirement {
	if x != nil {
		return x.PackageVettingRequirements
	}
	return nil
}

func (x *GetPreferredPackagesRequest) GetSynchronizerId() string {
	if x != nil {
		return x.SynchronizerId
	}
	return ""
}

func (x *GetPreferredPackagesRequest) GetVettingValidAt() *timestamppb.Timestamp {
	if x != nil {
		return x.VettingValidAt
	}
	return nil
}

type GetPreferredPackagesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The package references of the preferred packages.
	// Must contain one package reference for each requested package-name.
	//
	// If you build command submissions whose content depends on the returned
	// preferred packages, then we recommend submitting the preferred package-ids
	// in the “package_id_selection_preference“ of the command submission to
	// avoid race conditions with concurrent changes of the on-ledger package vetting state.
	//
	// Required
	PackageReferences []*v2.PackageReference `protobuf:"bytes,1,rep,name=package_references,json=packageReferences,proto3" json:"package_references,omitempty"`
	// The synchronizer for which the package preferences are computed.
	// If the synchronizer_id was specified in the request, then it matches the request synchronizer_id.
	// Required
	SynchronizerId string `protobuf:"bytes,2,opt,name=synchronizer_id,json=synchronizerId,proto3" json:"synchronizer_id,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GetPreferredPackagesResponse) Reset() {
	*x = GetPreferredPackagesResponse{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPreferredPackagesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPreferredPackagesResponse) ProtoMessage() {}

func (x *GetPreferredPackagesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPreferredPackagesResponse.ProtoReflect.Descriptor instead.
func (*GetPreferredPackagesResponse) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{21}
}

func (x *GetPreferredPackagesResponse) GetPackageReferences() []*v2.PackageReference {
	if x != nil {
		return x.PackageReferences
	}
	return nil
}

func (x *GetPreferredPackagesResponse) GetSynchronizerId() string {
	if x != nil {
		return x.SynchronizerId
	}
	return ""
}

type Metadata_SubmitterInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ActAs         []string               `protobuf:"bytes,1,rep,name=act_as,json=actAs,proto3" json:"act_as,omitempty"`
	CommandId     string                 `protobuf:"bytes,2,opt,name=command_id,json=commandId,proto3" json:"command_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Metadata_SubmitterInfo) Reset() {
	*x = Metadata_SubmitterInfo{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Metadata_SubmitterInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Metadata_SubmitterInfo) ProtoMessage() {}

func (x *Metadata_SubmitterInfo) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Metadata_SubmitterInfo.ProtoReflect.Descriptor instead.
func (*Metadata_SubmitterInfo) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{14, 0}
}

func (x *Metadata_SubmitterInfo) GetActAs() []string {
	if x != nil {
		return x.ActAs
	}
	return nil
}

func (x *Metadata_SubmitterInfo) GetCommandId() string {
	if x != nil {
		return x.CommandId
	}
	return ""
}

type Metadata_GlobalKeyMappingEntry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           *GlobalKey             `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         *v2.Value              `protobuf:"bytes,2,opt,name=value,proto3,oneof" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Metadata_GlobalKeyMappingEntry) Reset() {
	*x = Metadata_GlobalKeyMappingEntry{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Metadata_GlobalKeyMappingEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Metadata_GlobalKeyMappingEntry) ProtoMessage() {}

func (x *Metadata_GlobalKeyMappingEntry) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Metadata_GlobalKeyMappingEntry.ProtoReflect.Descriptor instead.
func (*Metadata_GlobalKeyMappingEntry) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{14, 1}
}

func (x *Metadata_GlobalKeyMappingEntry) GetKey() *GlobalKey {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *Metadata_GlobalKeyMappingEntry) GetValue() *v2.Value {
	if x != nil {
		return x.Value
	}
	return nil
}

type Metadata_InputContract struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Contract:
	//
	//	*Metadata_InputContract_V1
	Contract      isMetadata_InputContract_Contract `protobuf_oneof:"contract"`
	CreatedAt     uint64                            `protobuf:"varint,1000,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	EventBlob     []byte                            `protobuf:"bytes,1002,opt,name=event_blob,json=eventBlob,proto3" json:"event_blob,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Metadata_InputContract) Reset() {
	*x = Metadata_InputContract{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Metadata_InputContract) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Metadata_InputContract) ProtoMessage() {}

func (x *Metadata_InputContract) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Metadata_InputContract.ProtoReflect.Descriptor instead.
func (*Metadata_InputContract) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{14, 2}
}

func (x *Metadata_InputContract) GetContract() isMetadata_InputContract_Contract {
	if x != nil {
		return x.Contract
	}
	return nil
}

func (x *Metadata_InputContract) GetV1() *v1.Create {
	if x != nil {
		if x, ok := x.Contract.(*Metadata_InputContract_V1); ok {
			return x.V1
		}
	}
	return nil
}

func (x *Metadata_InputContract) GetCreatedAt() uint64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *Metadata_InputContract) GetEventBlob() []byte {
	if x != nil {
		return x.EventBlob
	}
	return nil
}

type isMetadata_InputContract_Contract interface {
	isMetadata_InputContract_Contract()
}

type Metadata_InputContract_V1 struct {
	// When new versions will be added, they will show here
	V1 *v1.Create `protobuf:"bytes,1,opt,name=v1,proto3,oneof"`
}

func (*Metadata_InputContract_V1) isMetadata_InputContract_Contract() {}

type DamlTransaction_NodeSeed struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeId        int32                  `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Seed          []byte                 `protobuf:"bytes,2,opt,name=seed,proto3" json:"seed,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DamlTransaction_NodeSeed) Reset() {
	*x = DamlTransaction_NodeSeed{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DamlTransaction_NodeSeed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DamlTransaction_NodeSeed) ProtoMessage() {}

func (x *DamlTransaction_NodeSeed) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DamlTransaction_NodeSeed.ProtoReflect.Descriptor instead.
func (*DamlTransaction_NodeSeed) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{15, 0}
}

func (x *DamlTransaction_NodeSeed) GetNodeId() int32 {
	if x != nil {
		return x.NodeId
	}
	return 0
}

func (x *DamlTransaction_NodeSeed) GetSeed() []byte {
	if x != nil {
		return x.Seed
	}
	return nil
}

// A transaction may contain nodes with different versions.
// Each node must be hashed using the hashing algorithm corresponding to its specific version.
// [docs-entry-start: DamlTransaction.Node]
type DamlTransaction_Node struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	NodeId string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Versioned node
	//
	// Types that are valid to be assigned to VersionedNode:
	//
	//	*DamlTransaction_Node_V1
	VersionedNode isDamlTransaction_Node_VersionedNode `protobuf_oneof:"versioned_node"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DamlTransaction_Node) Reset() {
	*x = DamlTransaction_Node{}
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DamlTransaction_Node) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DamlTransaction_Node) ProtoMessage() {}

func (x *DamlTransaction_Node) ProtoReflect() protoreflect.Message {
	mi := &file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DamlTransaction_Node.ProtoReflect.Descriptor instead.
func (*DamlTransaction_Node) Descriptor() ([]byte, []int) {
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP(), []int{15, 1}
}

func (x *DamlTransaction_Node) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *DamlTransaction_Node) GetVersionedNode() isDamlTransaction_Node_VersionedNode {
	if x != nil {
		return x.VersionedNode
	}
	return nil
}

func (x *DamlTransaction_Node) GetV1() *v1.Node {
	if x != nil {
		if x, ok := x.VersionedNode.(*DamlTransaction_Node_V1); ok {
			return x.V1
		}
	}
	return nil
}

type isDamlTransaction_Node_VersionedNode interface {
	isDamlTransaction_Node_VersionedNode()
}

type DamlTransaction_Node_V1 struct {
	// Start at 1000 so we can add more fields before if necessary
	// When new versions will be added, they will show here
	V1 *v1.Node `protobuf:"bytes,1000,opt,name=v1,proto3,oneof"`
}

func (*DamlTransaction_Node_V1) isDamlTransaction_Node_VersionedNode() {}

var File_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto protoreflect.FileDescriptor

const file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDesc = "" +
	"\n" +
	"Gcom/daml/ledger/api/v2/interactive/interactive_submission_service.proto\x12\"com.daml.ledger.api.v2.interactive\x1a%com/daml/ledger/api/v2/commands.proto\x1a#com/daml/ledger/api/v2/crypto.proto\x1aKcom/daml/ledger/api/v2/interactive/interactive_submission_common_data.proto\x1aScom/daml/ledger/api/v2/interactive/transaction/v1/interactive_submission_data.proto\x1a.com/daml/ledger/api/v2/package_reference.proto\x1a(com/daml/ledger/api/v2/transaction.proto\x1a/com/daml/ledger/api/v2/transaction_filter.proto\x1a\"com/daml/ledger/api/v2/value.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\x90\x01\n" +
	"\x13CostEstimationHints\x12\x1a\n" +
	"\bdisabled\x18\x01 \x01(\bR\bdisabled\x12]\n" +
	"\x13expected_signatures\x18\x02 \x03(\x0e2,.com.daml.ledger.api.v2.SigningAlgorithmSpecR\x12expectedSignatures\"\xe4\x02\n" +
	"\x0eCostEstimation\x12M\n" +
	"\x14estimation_timestamp\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\x13estimationTimestamp\x12^\n" +
	",confirmation_request_traffic_cost_estimation\x18\x02 \x01(\x04R(confirmationRequestTrafficCostEstimation\x12`\n" +
	"-confirmation_response_traffic_cost_estimation\x18\x03 \x01(\x04R)confirmationResponseTrafficCostEstimation\x12A\n" +
	"\x1dtotal_traffic_cost_estimation\x18\x04 \x01(\x04R\x1atotalTrafficCostEstimation\"\xdb\x06\n" +
	"\x18PrepareSubmissionRequest\x12\x17\n" +
	"\auser_id\x18\x01 \x01(\tR\x06userId\x12\x1d\n" +
	"\n" +
	"command_id\x18\x02 \x01(\tR\tcommandId\x12;\n" +
	"\bcommands\x18\x03 \x03(\v2\x1f.com.daml.ledger.api.v2.CommandR\bcommands\x12Y\n" +
	"\x0fmin_ledger_time\x18\x04 \x01(\v21.com.daml.ledger.api.v2.interactive.MinLedgerTimeR\rminLedgerTime\x12G\n" +
	"\x0fmax_record_time\x18\v \x01(\v2\x1a.google.protobuf.TimestampH\x00R\rmaxRecordTime\x88\x01\x01\x12\x15\n" +
	"\x06act_as\x18\x05 \x03(\tR\x05actAs\x12\x17\n" +
	"\aread_as\x18\x06 \x03(\tR\x06readAs\x12Z\n" +
	"\x13disclosed_contracts\x18\a \x03(\v2).com.daml.ledger.api.v2.DisclosedContractR\x12disclosedContracts\x12'\n" +
	"\x0fsynchronizer_id\x18\b \x01(\tR\x0esynchronizerId\x12E\n" +
	"\x1fpackage_id_selection_preference\x18\t \x03(\tR\x1cpackageIdSelectionPreference\x12'\n" +
	"\x0fverbose_hashing\x18\n" +
	" \x01(\bR\x0everboseHashing\x12a\n" +
	"\x16prefetch_contract_keys\x18\x0f \x03(\v2+.com.daml.ledger.api.v2.PrefetchContractKeyR\x14prefetchContractKeys\x12p\n" +
	"\x15estimate_traffic_cost\x18\x10 \x01(\v27.com.daml.ledger.api.v2.interactive.CostEstimationHintsH\x01R\x13estimateTrafficCost\x88\x01\x01B\x12\n" +
	"\x10_max_record_timeB\x18\n" +
	"\x16_estimate_traffic_cost\"\xeb\x03\n" +
	"\x19PrepareSubmissionResponse\x12j\n" +
	"\x14prepared_transaction\x18\x01 \x01(\v27.com.daml.ledger.api.v2.interactive.PreparedTransactionR\x13preparedTransaction\x12:\n" +
	"\x19prepared_transaction_hash\x18\x02 \x01(\fR\x17preparedTransactionHash\x12n\n" +
	"\x16hashing_scheme_version\x18\x03 \x01(\x0e28.com.daml.ledger.api.v2.interactive.HashingSchemeVersionR\x14hashingSchemeVersion\x12,\n" +
	"\x0fhashing_details\x18\x04 \x01(\tH\x00R\x0ehashingDetails\x88\x01\x01\x12`\n" +
	"\x0fcost_estimation\x18\x05 \x01(\v22.com.daml.ledger.api.v2.interactive.CostEstimationH\x01R\x0ecostEstimation\x88\x01\x01B\x12\n" +
	"\x10_hashing_detailsB\x12\n" +
	"\x10_cost_estimation\"p\n" +
	"\x15SinglePartySignatures\x12\x14\n" +
	"\x05party\x18\x01 \x01(\tR\x05party\x12A\n" +
	"\n" +
	"signatures\x18\x02 \x03(\v2!.com.daml.ledger.api.v2.SignatureR\n" +
	"signatures\"l\n" +
	"\x0fPartySignatures\x12Y\n" +
	"\n" +
	"signatures\x18\x01 \x03(\v29.com.daml.ledger.api.v2.interactive.SinglePartySignaturesR\n" +
	"signatures\"\x90\x05\n" +
	"\x18ExecuteSubmissionRequest\x12j\n" +
	"\x14prepared_transaction\x18\x01 \x01(\v27.com.daml.ledger.api.v2.interactive.PreparedTransactionR\x13preparedTransaction\x12^\n" +
	"\x10party_signatures\x18\x02 \x01(\v23.com.daml.ledger.api.v2.interactive.PartySignaturesR\x0fpartySignatures\x12R\n" +
	"\x16deduplication_duration\x18\x03 \x01(\v2\x19.google.protobuf.DurationH\x00R\x15deduplicationDuration\x123\n" +
	"\x14deduplication_offset\x18\x04 \x01(\x03H\x00R\x13deduplicationOffset\x12#\n" +
	"\rsubmission_id\x18\x05 \x01(\tR\fsubmissionId\x12\x17\n" +
	"\auser_id\x18\x06 \x01(\tR\x06userId\x12n\n" +
	"\x16hashing_scheme_version\x18\a \x01(\x0e28.com.daml.ledger.api.v2.interactive.HashingSchemeVersionR\x14hashingSchemeVersion\x12Y\n" +
	"\x0fmin_ledger_time\x18\b \x01(\v21.com.daml.ledger.api.v2.interactive.MinLedgerTimeR\rminLedgerTimeB\x16\n" +
	"\x14deduplication_period\"\x1b\n" +
	"\x19ExecuteSubmissionResponse\"\x97\x05\n" +
	"\x1fExecuteSubmissionAndWaitRequest\x12j\n" +
	"\x14prepared_transaction\x18\x01 \x01(\v27.com.daml.ledger.api.v2.interactive.PreparedTransactionR\x13preparedTransaction\x12^\n" +
	"\x10party_signatures\x18\x02 \x01(\v23.com.daml.ledger.api.v2.interactive.PartySignaturesR\x0fpartySignatures\x12R\n" +
	"\x16deduplication_duration\x18\x03 \x01(\v2\x19.google.protobuf.DurationH\x00R\x15deduplicationDuration\x123\n" +
	"\x14deduplication_offset\x18\x04 \x01(\x03H\x00R\x13deduplicationOffset\x12#\n" +
	"\rsubmission_id\x18\x05 \x01(\tR\fsubmissionId\x12\x17\n" +
	"\auser_id\x18\x06 \x01(\tR\x06userId\x12n\n" +
	"\x16hashing_scheme_version\x18\a \x01(\x0e28.com.daml.ledger.api.v2.interactive.HashingSchemeVersionR\x14hashingSchemeVersion\x12Y\n" +
	"\x0fmin_ledger_time\x18\b \x01(\v21.com.daml.ledger.api.v2.interactive.MinLedgerTimeR\rminLedgerTimeB\x16\n" +
	"\x14deduplication_period\"l\n" +
	" ExecuteSubmissionAndWaitResponse\x12\x1b\n" +
	"\tupdate_id\x18\x01 \x01(\tR\bupdateId\x12+\n" +
	"\x11completion_offset\x18\x02 \x01(\x03R\x10completionOffset\"\xff\x05\n" +
	"-ExecuteSubmissionAndWaitForTransactionRequest\x12j\n" +
	"\x14prepared_transaction\x18\x01 \x01(\v27.com.daml.ledger.api.v2.interactive.PreparedTransactionR\x13preparedTransaction\x12^\n" +
	"\x10party_signatures\x18\x02 \x01(\v23.com.daml.ledger.api.v2.interactive.PartySignaturesR\x0fpartySignatures\x12R\n" +
	"\x16deduplication_duration\x18\x03 \x01(\v2\x19.google.protobuf.DurationH\x00R\x15deduplicationDuration\x123\n" +
	"\x14deduplication_offset\x18\x04 \x01(\x03H\x00R\x13deduplicationOffset\x12#\n" +
	"\rsubmission_id\x18\x05 \x01(\tR\fsubmissionId\x12\x17\n" +
	"\auser_id\x18\x06 \x01(\tR\x06userId\x12n\n" +
	"\x16hashing_scheme_version\x18\a \x01(\x0e28.com.daml.ledger.api.v2.interactive.HashingSchemeVersionR\x14hashingSchemeVersion\x12Y\n" +
	"\x0fmin_ledger_time\x18\b \x01(\v21.com.daml.ledger.api.v2.interactive.MinLedgerTimeR\rminLedgerTime\x12X\n" +
	"\x12transaction_format\x18\t \x01(\v2).com.daml.ledger.api.v2.TransactionFormatR\x11transactionFormatB\x16\n" +
	"\x14deduplication_period\"w\n" +
	".ExecuteSubmissionAndWaitForTransactionResponse\x12E\n" +
	"\vtransaction\x18\x01 \x01(\v2#.com.daml.ledger.api.v2.TransactionR\vtransaction\"\xb0\x01\n" +
	"\rMinLedgerTime\x12K\n" +
	"\x13min_ledger_time_abs\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampH\x00R\x10minLedgerTimeAbs\x12J\n" +
	"\x13min_ledger_time_rel\x18\x02 \x01(\v2\x19.google.protobuf.DurationH\x00R\x10minLedgerTimeRelB\x06\n" +
	"\x04time\"\xb6\x01\n" +
	"\x13PreparedTransaction\x12U\n" +
	"\vtransaction\x18\x01 \x01(\v23.com.daml.ledger.api.v2.interactive.DamlTransactionR\vtransaction\x12H\n" +
	"\bmetadata\x18\x02 \x01(\v2,.com.daml.ledger.api.v2.interactive.MetadataR\bmetadata\"\x86\t\n" +
	"\bMetadata\x12a\n" +
	"\x0esubmitter_info\x18\x02 \x01(\v2:.com.daml.ledger.api.v2.interactive.Metadata.SubmitterInfoR\rsubmitterInfo\x12'\n" +
	"\x0fsynchronizer_id\x18\x03 \x01(\tR\x0esynchronizerId\x12%\n" +
	"\x0emediator_group\x18\x04 \x01(\rR\rmediatorGroup\x12)\n" +
	"\x10transaction_uuid\x18\x05 \x01(\tR\x0ftransactionUuid\x12)\n" +
	"\x10preparation_time\x18\x06 \x01(\x04R\x0fpreparationTime\x12c\n" +
	"\x0finput_contracts\x18\a \x03(\v2:.com.daml.ledger.api.v2.interactive.Metadata.InputContractR\x0einputContracts\x12>\n" +
	"\x19min_ledger_effective_time\x18\t \x01(\x04H\x00R\x16minLedgerEffectiveTime\x88\x01\x01\x12>\n" +
	"\x19max_ledger_effective_time\x18\n" +
	" \x01(\x04H\x01R\x16maxLedgerEffectiveTime\x88\x01\x01\x12p\n" +
	"\x12global_key_mapping\x18\b \x03(\v2B.com.daml.ledger.api.v2.interactive.Metadata.GlobalKeyMappingEntryR\x10globalKeyMapping\x12+\n" +
	"\x0fmax_record_time\x18\v \x01(\x04H\x02R\rmaxRecordTime\x88\x01\x01\x1aE\n" +
	"\rSubmitterInfo\x12\x15\n" +
	"\x06act_as\x18\x01 \x03(\tR\x05actAs\x12\x1d\n" +
	"\n" +
	"command_id\x18\x02 \x01(\tR\tcommandId\x1a\x9c\x01\n" +
	"\x15GlobalKeyMappingEntry\x12?\n" +
	"\x03key\x18\x01 \x01(\v2-.com.daml.ledger.api.v2.interactive.GlobalKeyR\x03key\x128\n" +
	"\x05value\x18\x02 \x01(\v2\x1d.com.daml.ledger.api.v2.ValueH\x00R\x05value\x88\x01\x01B\b\n" +
	"\x06_value\x1a\xb0\x01\n" +
	"\rInputContract\x12K\n" +
	"\x02v1\x18\x01 \x01(\v29.com.daml.ledger.api.v2.interactive.transaction.v1.CreateH\x00R\x02v1\x12\x1e\n" +
	"\n" +
	"created_at\x18\xe8\a \x01(\x04R\tcreatedAt\x12\x1e\n" +
	"\n" +
	"event_blob\x18\xea\a \x01(\fR\teventBlobB\n" +
	"\n" +
	"\bcontractJ\x06\b\xe9\a\x10\xea\aB\x1c\n" +
	"\x1a_min_ledger_effective_timeB\x1c\n" +
	"\x1a_max_ledger_effective_timeB\x12\n" +
	"\x10_max_record_timeJ\x04\b\x01\x10\x02\"\xa6\x03\n" +
	"\x0fDamlTransaction\x12\x18\n" +
	"\aversion\x18\x01 \x01(\tR\aversion\x12\x14\n" +
	"\x05roots\x18\x02 \x03(\tR\x05roots\x12N\n" +
	"\x05nodes\x18\x03 \x03(\v28.com.daml.ledger.api.v2.interactive.DamlTransaction.NodeR\x05nodes\x12[\n" +
	"\n" +
	"node_seeds\x18\x04 \x03(\v2<.com.daml.ledger.api.v2.interactive.DamlTransaction.NodeSeedR\tnodeSeeds\x1a7\n" +
	"\bNodeSeed\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\x05R\x06nodeId\x12\x12\n" +
	"\x04seed\x18\x02 \x01(\fR\x04seed\x1a}\n" +
	"\x04Node\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12J\n" +
	"\x02v1\x18\xe8\a \x01(\v27.com.daml.ledger.api.v2.interactive.transaction.v1.NodeH\x00R\x02v1B\x10\n" +
	"\x0eversioned_node\"\xcf\x01\n" +
	"!GetPreferredPackageVersionRequest\x12\x18\n" +
	"\aparties\x18\x01 \x03(\tR\aparties\x12!\n" +
	"\fpackage_name\x18\x02 \x01(\tR\vpackageName\x12'\n" +
	"\x0fsynchronizer_id\x18\x03 \x01(\tR\x0esynchronizerId\x12D\n" +
	"\x10vetting_valid_at\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x0evettingValidAt\"\x8a\x01\n" +
	"\"GetPreferredPackageVersionResponse\x12d\n" +
	"\x12package_preference\x18\x01 \x01(\v25.com.daml.ledger.api.v2.interactive.PackagePreferenceR\x11packagePreference\"\x93\x01\n" +
	"\x11PackagePreference\x12U\n" +
	"\x11package_reference\x18\x01 \x01(\v2(.com.daml.ledger.api.v2.PackageReferenceR\x10packageReference\x12'\n" +
	"\x0fsynchronizer_id\x18\x02 \x01(\tR\x0esynchronizerId\"X\n" +
	"\x19PackageVettingRequirement\x12\x18\n" +
	"\aparties\x18\x01 \x03(\tR\aparties\x12!\n" +
	"\fpackage_name\x18\x02 \x01(\tR\vpackageName\"\x8d\x02\n" +
	"\x1bGetPreferredPackagesRequest\x12\x7f\n" +
	"\x1cpackage_vetting_requirements\x18\x01 \x03(\v2=.com.daml.ledger.api.v2.interactive.PackageVettingRequirementR\x1apackageVettingRequirements\x12'\n" +
	"\x0fsynchronizer_id\x18\x02 \x01(\tR\x0esynchronizerId\x12D\n" +
	"\x10vetting_valid_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\x0evettingValidAt\"\xa0\x01\n" +
	"\x1cGetPreferredPackagesResponse\x12W\n" +
	"\x12package_references\x18\x01 \x03(\v2(.com.daml.ledger.api.v2.PackageReferenceR\x11packageReferences\x12'\n" +
	"\x0fsynchronizer_id\x18\x02 \x01(\tR\x0esynchronizerId*c\n" +
	"\x14HashingSchemeVersion\x12&\n" +
	"\"HASHING_SCHEME_VERSION_UNSPECIFIED\x10\x00\x12\x1d\n" +
	"\x19HASHING_SCHEME_VERSION_V2\x10\x02\"\x04\b\x01\x10\x012\x88\b\n" +
	"\x1cInteractiveSubmissionService\x12\x90\x01\n" +
	"\x11PrepareSubmission\x12<.com.daml.ledger.api.v2.interactive.PrepareSubmissionRequest\x1a=.com.daml.ledger.api.v2.interactive.PrepareSubmissionResponse\x12\x90\x01\n" +
	"\x11ExecuteSubmission\x12<.com.daml.ledger.api.v2.interactive.ExecuteSubmissionRequest\x1a=.com.daml.ledger.api.v2.interactive.ExecuteSubmissionResponse\x12\xa5\x01\n" +
	"\x18ExecuteSubmissionAndWait\x12C.com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitRequest\x1aD.com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitResponse\x12\xcf\x01\n" +
	"&ExecuteSubmissionAndWaitForTransaction\x12Q.com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitForTransactionRequest\x1aR.com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitForTransactionResponse\x12\xab\x01\n" +
	"\x1aGetPreferredPackageVersion\x12E.com.daml.ledger.api.v2.interactive.GetPreferredPackageVersionRequest\x1aF.com.daml.ledger.api.v2.interactive.GetPreferredPackageVersionResponse\x12\x99\x01\n" +
	"\x14GetPreferredPackages\x12?.com.daml.ledger.api.v2.interactive.GetPreferredPackagesRequest\x1a@.com.daml.ledger.api.v2.interactive.GetPreferredPackagesResponseB\xba\x02\n" +
	"&com.com.daml.ledger.api.v2.interactiveB!InteractiveSubmissionServiceProtoP\x01Z=buf-lib-poc/pkg/daml/proto/com/daml/ledger/api/v2/interactive\xa2\x02\x06CDLAVI\xaa\x02\"Com.Daml.Ledger.Api.V2.Interactive\xca\x02\"Com\\Daml\\Ledger\\Api\\V2\\Interactive\xe2\x02.Com\\Daml\\Ledger\\Api\\V2\\Interactive\\GPBMetadata\xea\x02'Com::Daml::Ledger::Api::V2::Interactiveb\x06proto3"

var (
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescOnce sync.Once
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescData []byte
)

func file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescGZIP() []byte {
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescOnce.Do(func() {
		file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDesc), len(file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDesc)))
	})
	return file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDescData
}

var file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes = make([]protoimpl.MessageInfo, 27)
var file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_goTypes = []any{
	(HashingSchemeVersion)(0),                              // 0: com.daml.ledger.api.v2.interactive.HashingSchemeVersion
	(*CostEstimationHints)(nil),                            // 1: com.daml.ledger.api.v2.interactive.CostEstimationHints
	(*CostEstimation)(nil),                                 // 2: com.daml.ledger.api.v2.interactive.CostEstimation
	(*PrepareSubmissionRequest)(nil),                       // 3: com.daml.ledger.api.v2.interactive.PrepareSubmissionRequest
	(*PrepareSubmissionResponse)(nil),                      // 4: com.daml.ledger.api.v2.interactive.PrepareSubmissionResponse
	(*SinglePartySignatures)(nil),                          // 5: com.daml.ledger.api.v2.interactive.SinglePartySignatures
	(*PartySignatures)(nil),                                // 6: com.daml.ledger.api.v2.interactive.PartySignatures
	(*ExecuteSubmissionRequest)(nil),                       // 7: com.daml.ledger.api.v2.interactive.ExecuteSubmissionRequest
	(*ExecuteSubmissionResponse)(nil),                      // 8: com.daml.ledger.api.v2.interactive.ExecuteSubmissionResponse
	(*ExecuteSubmissionAndWaitRequest)(nil),                // 9: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitRequest
	(*ExecuteSubmissionAndWaitResponse)(nil),               // 10: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitResponse
	(*ExecuteSubmissionAndWaitForTransactionRequest)(nil),  // 11: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitForTransactionRequest
	(*ExecuteSubmissionAndWaitForTransactionResponse)(nil), // 12: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitForTransactionResponse
	(*MinLedgerTime)(nil),                                  // 13: com.daml.ledger.api.v2.interactive.MinLedgerTime
	(*PreparedTransaction)(nil),                            // 14: com.daml.ledger.api.v2.interactive.PreparedTransaction
	(*Metadata)(nil),                                       // 15: com.daml.ledger.api.v2.interactive.Metadata
	(*DamlTransaction)(nil),                                // 16: com.daml.ledger.api.v2.interactive.DamlTransaction
	(*GetPreferredPackageVersionRequest)(nil),              // 17: com.daml.ledger.api.v2.interactive.GetPreferredPackageVersionRequest
	(*GetPreferredPackageVersionResponse)(nil),             // 18: com.daml.ledger.api.v2.interactive.GetPreferredPackageVersionResponse
	(*PackagePreference)(nil),                              // 19: com.daml.ledger.api.v2.interactive.PackagePreference
	(*PackageVettingRequirement)(nil),                      // 20: com.daml.ledger.api.v2.interactive.PackageVettingRequirement
	(*GetPreferredPackagesRequest)(nil),                    // 21: com.daml.ledger.api.v2.interactive.GetPreferredPackagesRequest
	(*GetPreferredPackagesResponse)(nil),                   // 22: com.daml.ledger.api.v2.interactive.GetPreferredPackagesResponse
	(*Metadata_SubmitterInfo)(nil),                         // 23: com.daml.ledger.api.v2.interactive.Metadata.SubmitterInfo
	(*Metadata_GlobalKeyMappingEntry)(nil),                 // 24: com.daml.ledger.api.v2.interactive.Metadata.GlobalKeyMappingEntry
	(*Metadata_InputContract)(nil),                         // 25: com.daml.ledger.api.v2.interactive.Metadata.InputContract
	(*DamlTransaction_NodeSeed)(nil),                       // 26: com.daml.ledger.api.v2.interactive.DamlTransaction.NodeSeed
	(*DamlTransaction_Node)(nil),                           // 27: com.daml.ledger.api.v2.interactive.DamlTransaction.Node
	(v2.SigningAlgorithmSpec)(0),                           // 28: com.daml.ledger.api.v2.SigningAlgorithmSpec
	(*timestamppb.Timestamp)(nil),                          // 29: google.protobuf.Timestamp
	(*v2.Command)(nil),                                     // 30: com.daml.ledger.api.v2.Command
	(*v2.DisclosedContract)(nil),                           // 31: com.daml.ledger.api.v2.DisclosedContract
	(*v2.PrefetchContractKey)(nil),                         // 32: com.daml.ledger.api.v2.PrefetchContractKey
	(*v2.Signature)(nil),                                   // 33: com.daml.ledger.api.v2.Signature
	(*durationpb.Duration)(nil),                            // 34: google.protobuf.Duration
	(*v2.TransactionFormat)(nil),                           // 35: com.daml.ledger.api.v2.TransactionFormat
	(*v2.Transaction)(nil),                                 // 36: com.daml.ledger.api.v2.Transaction
	(*v2.PackageReference)(nil),                            // 37: com.daml.ledger.api.v2.PackageReference
	(*GlobalKey)(nil),                                      // 38: com.daml.ledger.api.v2.interactive.GlobalKey
	(*v2.Value)(nil),                                       // 39: com.daml.ledger.api.v2.Value
	(*v1.Create)(nil),                                      // 40: com.daml.ledger.api.v2.interactive.transaction.v1.Create
	(*v1.Node)(nil),                                        // 41: com.daml.ledger.api.v2.interactive.transaction.v1.Node
}
var file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_depIdxs = []int32{
	28, // 0: com.daml.ledger.api.v2.interactive.CostEstimationHints.expected_signatures:type_name -> com.daml.ledger.api.v2.SigningAlgorithmSpec
	29, // 1: com.daml.ledger.api.v2.interactive.CostEstimation.estimation_timestamp:type_name -> google.protobuf.Timestamp
	30, // 2: com.daml.ledger.api.v2.interactive.PrepareSubmissionRequest.commands:type_name -> com.daml.ledger.api.v2.Command
	13, // 3: com.daml.ledger.api.v2.interactive.PrepareSubmissionRequest.min_ledger_time:type_name -> com.daml.ledger.api.v2.interactive.MinLedgerTime
	29, // 4: com.daml.ledger.api.v2.interactive.PrepareSubmissionRequest.max_record_time:type_name -> google.protobuf.Timestamp
	31, // 5: com.daml.ledger.api.v2.interactive.PrepareSubmissionRequest.disclosed_contracts:type_name -> com.daml.ledger.api.v2.DisclosedContract
	32, // 6: com.daml.ledger.api.v2.interactive.PrepareSubmissionRequest.prefetch_contract_keys:type_name -> com.daml.ledger.api.v2.PrefetchContractKey
	1,  // 7: com.daml.ledger.api.v2.interactive.PrepareSubmissionRequest.estimate_traffic_cost:type_name -> com.daml.ledger.api.v2.interactive.CostEstimationHints
	14, // 8: com.daml.ledger.api.v2.interactive.PrepareSubmissionResponse.prepared_transaction:type_name -> com.daml.ledger.api.v2.interactive.PreparedTransaction
	0,  // 9: com.daml.ledger.api.v2.interactive.PrepareSubmissionResponse.hashing_scheme_version:type_name -> com.daml.ledger.api.v2.interactive.HashingSchemeVersion
	2,  // 10: com.daml.ledger.api.v2.interactive.PrepareSubmissionResponse.cost_estimation:type_name -> com.daml.ledger.api.v2.interactive.CostEstimation
	33, // 11: com.daml.ledger.api.v2.interactive.SinglePartySignatures.signatures:type_name -> com.daml.ledger.api.v2.Signature
	5,  // 12: com.daml.ledger.api.v2.interactive.PartySignatures.signatures:type_name -> com.daml.ledger.api.v2.interactive.SinglePartySignatures
	14, // 13: com.daml.ledger.api.v2.interactive.ExecuteSubmissionRequest.prepared_transaction:type_name -> com.daml.ledger.api.v2.interactive.PreparedTransaction
	6,  // 14: com.daml.ledger.api.v2.interactive.ExecuteSubmissionRequest.party_signatures:type_name -> com.daml.ledger.api.v2.interactive.PartySignatures
	34, // 15: com.daml.ledger.api.v2.interactive.ExecuteSubmissionRequest.deduplication_duration:type_name -> google.protobuf.Duration
	0,  // 16: com.daml.ledger.api.v2.interactive.ExecuteSubmissionRequest.hashing_scheme_version:type_name -> com.daml.ledger.api.v2.interactive.HashingSchemeVersion
	13, // 17: com.daml.ledger.api.v2.interactive.ExecuteSubmissionRequest.min_ledger_time:type_name -> com.daml.ledger.api.v2.interactive.MinLedgerTime
	14, // 18: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitRequest.prepared_transaction:type_name -> com.daml.ledger.api.v2.interactive.PreparedTransaction
	6,  // 19: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitRequest.party_signatures:type_name -> com.daml.ledger.api.v2.interactive.PartySignatures
	34, // 20: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitRequest.deduplication_duration:type_name -> google.protobuf.Duration
	0,  // 21: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitRequest.hashing_scheme_version:type_name -> com.daml.ledger.api.v2.interactive.HashingSchemeVersion
	13, // 22: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitRequest.min_ledger_time:type_name -> com.daml.ledger.api.v2.interactive.MinLedgerTime
	14, // 23: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitForTransactionRequest.prepared_transaction:type_name -> com.daml.ledger.api.v2.interactive.PreparedTransaction
	6,  // 24: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitForTransactionRequest.party_signatures:type_name -> com.daml.ledger.api.v2.interactive.PartySignatures
	34, // 25: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitForTransactionRequest.deduplication_duration:type_name -> google.protobuf.Duration
	0,  // 26: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitForTransactionRequest.hashing_scheme_version:type_name -> com.daml.ledger.api.v2.interactive.HashingSchemeVersion
	13, // 27: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitForTransactionRequest.min_ledger_time:type_name -> com.daml.ledger.api.v2.interactive.MinLedgerTime
	35, // 28: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitForTransactionRequest.transaction_format:type_name -> com.daml.ledger.api.v2.TransactionFormat
	36, // 29: com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitForTransactionResponse.transaction:type_name -> com.daml.ledger.api.v2.Transaction
	29, // 30: com.daml.ledger.api.v2.interactive.MinLedgerTime.min_ledger_time_abs:type_name -> google.protobuf.Timestamp
	34, // 31: com.daml.ledger.api.v2.interactive.MinLedgerTime.min_ledger_time_rel:type_name -> google.protobuf.Duration
	16, // 32: com.daml.ledger.api.v2.interactive.PreparedTransaction.transaction:type_name -> com.daml.ledger.api.v2.interactive.DamlTransaction
	15, // 33: com.daml.ledger.api.v2.interactive.PreparedTransaction.metadata:type_name -> com.daml.ledger.api.v2.interactive.Metadata
	23, // 34: com.daml.ledger.api.v2.interactive.Metadata.submitter_info:type_name -> com.daml.ledger.api.v2.interactive.Metadata.SubmitterInfo
	25, // 35: com.daml.ledger.api.v2.interactive.Metadata.input_contracts:type_name -> com.daml.ledger.api.v2.interactive.Metadata.InputContract
	24, // 36: com.daml.ledger.api.v2.interactive.Metadata.global_key_mapping:type_name -> com.daml.ledger.api.v2.interactive.Metadata.GlobalKeyMappingEntry
	27, // 37: com.daml.ledger.api.v2.interactive.DamlTransaction.nodes:type_name -> com.daml.ledger.api.v2.interactive.DamlTransaction.Node
	26, // 38: com.daml.ledger.api.v2.interactive.DamlTransaction.node_seeds:type_name -> com.daml.ledger.api.v2.interactive.DamlTransaction.NodeSeed
	29, // 39: com.daml.ledger.api.v2.interactive.GetPreferredPackageVersionRequest.vetting_valid_at:type_name -> google.protobuf.Timestamp
	19, // 40: com.daml.ledger.api.v2.interactive.GetPreferredPackageVersionResponse.package_preference:type_name -> com.daml.ledger.api.v2.interactive.PackagePreference
	37, // 41: com.daml.ledger.api.v2.interactive.PackagePreference.package_reference:type_name -> com.daml.ledger.api.v2.PackageReference
	20, // 42: com.daml.ledger.api.v2.interactive.GetPreferredPackagesRequest.package_vetting_requirements:type_name -> com.daml.ledger.api.v2.interactive.PackageVettingRequirement
	29, // 43: com.daml.ledger.api.v2.interactive.GetPreferredPackagesRequest.vetting_valid_at:type_name -> google.protobuf.Timestamp
	37, // 44: com.daml.ledger.api.v2.interactive.GetPreferredPackagesResponse.package_references:type_name -> com.daml.ledger.api.v2.PackageReference
	38, // 45: com.daml.ledger.api.v2.interactive.Metadata.GlobalKeyMappingEntry.key:type_name -> com.daml.ledger.api.v2.interactive.GlobalKey
	39, // 46: com.daml.ledger.api.v2.interactive.Metadata.GlobalKeyMappingEntry.value:type_name -> com.daml.ledger.api.v2.Value
	40, // 47: com.daml.ledger.api.v2.interactive.Metadata.InputContract.v1:type_name -> com.daml.ledger.api.v2.interactive.transaction.v1.Create
	41, // 48: com.daml.ledger.api.v2.interactive.DamlTransaction.Node.v1:type_name -> com.daml.ledger.api.v2.interactive.transaction.v1.Node
	3,  // 49: com.daml.ledger.api.v2.interactive.InteractiveSubmissionService.PrepareSubmission:input_type -> com.daml.ledger.api.v2.interactive.PrepareSubmissionRequest
	7,  // 50: com.daml.ledger.api.v2.interactive.InteractiveSubmissionService.ExecuteSubmission:input_type -> com.daml.ledger.api.v2.interactive.ExecuteSubmissionRequest
	9,  // 51: com.daml.ledger.api.v2.interactive.InteractiveSubmissionService.ExecuteSubmissionAndWait:input_type -> com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitRequest
	11, // 52: com.daml.ledger.api.v2.interactive.InteractiveSubmissionService.ExecuteSubmissionAndWaitForTransaction:input_type -> com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitForTransactionRequest
	17, // 53: com.daml.ledger.api.v2.interactive.InteractiveSubmissionService.GetPreferredPackageVersion:input_type -> com.daml.ledger.api.v2.interactive.GetPreferredPackageVersionRequest
	21, // 54: com.daml.ledger.api.v2.interactive.InteractiveSubmissionService.GetPreferredPackages:input_type -> com.daml.ledger.api.v2.interactive.GetPreferredPackagesRequest
	4,  // 55: com.daml.ledger.api.v2.interactive.InteractiveSubmissionService.PrepareSubmission:output_type -> com.daml.ledger.api.v2.interactive.PrepareSubmissionResponse
	8,  // 56: com.daml.ledger.api.v2.interactive.InteractiveSubmissionService.ExecuteSubmission:output_type -> com.daml.ledger.api.v2.interactive.ExecuteSubmissionResponse
	10, // 57: com.daml.ledger.api.v2.interactive.InteractiveSubmissionService.ExecuteSubmissionAndWait:output_type -> com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitResponse
	12, // 58: com.daml.ledger.api.v2.interactive.InteractiveSubmissionService.ExecuteSubmissionAndWaitForTransaction:output_type -> com.daml.ledger.api.v2.interactive.ExecuteSubmissionAndWaitForTransactionResponse
	18, // 59: com.daml.ledger.api.v2.interactive.InteractiveSubmissionService.GetPreferredPackageVersion:output_type -> com.daml.ledger.api.v2.interactive.GetPreferredPackageVersionResponse
	22, // 60: com.daml.ledger.api.v2.interactive.InteractiveSubmissionService.GetPreferredPackages:output_type -> com.daml.ledger.api.v2.interactive.GetPreferredPackagesResponse
	55, // [55:61] is the sub-list for method output_type
	49, // [49:55] is the sub-list for method input_type
	49, // [49:49] is the sub-list for extension type_name
	49, // [49:49] is the sub-list for extension extendee
	0,  // [0:49] is the sub-list for field type_name
}

func init() { file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_init() }
func file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_init() {
	if File_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto != nil {
		return
	}
	file_com_daml_ledger_api_v2_interactive_interactive_submission_common_data_proto_init()
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[2].OneofWrappers = []any{}
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[3].OneofWrappers = []any{}
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[6].OneofWrappers = []any{
		(*ExecuteSubmissionRequest_DeduplicationDuration)(nil),
		(*ExecuteSubmissionRequest_DeduplicationOffset)(nil),
	}
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[8].OneofWrappers = []any{
		(*ExecuteSubmissionAndWaitRequest_DeduplicationDuration)(nil),
		(*ExecuteSubmissionAndWaitRequest_DeduplicationOffset)(nil),
	}
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[10].OneofWrappers = []any{
		(*ExecuteSubmissionAndWaitForTransactionRequest_DeduplicationDuration)(nil),
		(*ExecuteSubmissionAndWaitForTransactionRequest_DeduplicationOffset)(nil),
	}
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[12].OneofWrappers = []any{
		(*MinLedgerTime_MinLedgerTimeAbs)(nil),
		(*MinLedgerTime_MinLedgerTimeRel)(nil),
	}
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[14].OneofWrappers = []any{}
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[23].OneofWrappers = []any{}
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[24].OneofWrappers = []any{
		(*Metadata_InputContract_V1)(nil),
	}
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes[26].OneofWrappers = []any{
		(*DamlTransaction_Node_V1)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDesc), len(file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   27,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_goTypes,
		DependencyIndexes: file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_depIdxs,
		EnumInfos:         file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_enumTypes,
		MessageInfos:      file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_msgTypes,
	}.Build()
	File_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto = out.File
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_goTypes = nil
	file_com_daml_ledger_api_v2_interactive_interactive_submission_service_proto_depIdxs = nil
}
